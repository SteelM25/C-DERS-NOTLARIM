# âœ… **Eklemende Fayda Olan Konular (Ã–zet + AÃ§Ä±klama)**

---

## **1ï¸âƒ£ Stack Bellekte Fonksiyon Ã‡aÄŸrÄ±sÄ± (Call Stack)**

Stack sadece â€œyerel deÄŸiÅŸkenâ€ tutmaz; aynÄ± zamanda:

* **Fonksiyon dÃ¶nÃ¼ÅŸ adresi**
* **Fonksiyon parametreleri**
* **Kopyalanan geÃ§ici deÄŸerler**
* **Return edilen deÄŸerlerin bazÄ± tÃ¼rleri (Ã¶rneÄŸin kÃ¼Ã§Ã¼k POD tipleri)**

bu yapÄ±nÄ±n iÃ§inde tutulur.

ğŸ“Œ Ã–nemli Ã‡Ã¼nkÃ¼:
Stack taÅŸmasÄ± (**Stack Overflow**) genellikle sonsuz Ã¶zyineleme (recursive) sonucu olur.

---

## **2ï¸âƒ£ Heap Bellekte new / delete Uyum Tablosu**

C++'ta **new** ile aÃ§Ä±lan bellek **delete**,
**new[]** ile aÃ§Ä±lan bellek **delete[]** ile silinir.

YanlÄ±ÅŸ kombinasyon **tanÄ±msÄ±z davranÄ±ÅŸ (undefined behavior)** Ã¼retir.

```cpp
int* p = new int;
delete p;      // doÄŸru

int* arr = new int[10];
delete[] arr;  // doÄŸru
```

âŒ Bunlar hatalÄ±:

```cpp
delete[] p;
delete arr;
```

---

## **3ï¸âƒ£ Dangling Pointer ve Memory Leak**

Heap kullanÄ±rken en Ã¶nemli 2 hata tipi:

### **ğŸ”¸ Memory Leak**

delete unutulursa bellek geri verilmez â†’ program kapanana kadar boÅŸ yere yer kaplar.

### **ğŸ”¸ Dangling Pointer**

Bellek silindikten sonra hÃ¢lÃ¢ aynÄ± pointer'Ä± kullanmaya Ã§alÄ±ÅŸmak.

```cpp
int* p = new int(5);
delete p;
cout << *p;     // âš ï¸ undefined behavior
```

Bunu Ã¶nlemek iÃ§in genelde:

```cpp
p = nullptr;
```

kullanÄ±lÄ±r.

---

## **4ï¸âƒ£ nullptr, NULL ve 0 FarkÄ±**

Modern C++â€™ta **nullptr** kullanÄ±lÄ±r.

* `nullptr` â†’ tÃ¼rÃ¼ belli, gÃ¼venli
* `NULL` â†’ eski C tarzÄ±, makro
* `0` â†’ tam sayÄ± 0â€™dÄ±r, pointer deÄŸildir

---

## **5ï¸âƒ£ Heapâ€™in Stackâ€™ten Daha YavaÅŸ OlmasÄ±nÄ±n Nedeni**

Ã‡Ã¼nkÃ¼:

* Stack: CPU tarafÄ±ndan otomatik yÃ¶netilir (Ã§ok hÄ±zlÄ±)
* Heap: Ä°ÅŸletim sistemi veya allocator yÃ¶netir (yavaÅŸâ€“fragmentation olabilir)

---

## **6ï¸âƒ£ Stack SÄ±nÄ±rlÄ±dÄ±r, Heap Ã‡ok Daha BÃ¼yÃ¼ktÃ¼r**

Stack boyutu genellikle:

* Linux/Mac: ~8MB
* Windows: ~1MB

Heap ise sistem RAMâ€™i kadar bÃ¼yÃ¼k olabilir.

Bu yÃ¼zden bÃ¼yÃ¼k diziler heapâ€™te tutulur, yani pointer ile atanÄ±r.:

```cpp
int arr[1'000'000];       // stack overflow riski
int* arr = new int[1'000'000];  // heap'te gÃ¼venli
```

---

## **7ï¸âƒ£ RAII ve Smart Pointerâ€™lar (Modern C++ Ä°Ã§in)**

Heapâ€™i manuel yÃ¶netmek hataya Ã§ok aÃ§Ä±ktÄ±r.
Modern C++â€™ta tercih edilen yÃ¶ntem:

* `std::unique_ptr`
* `std::shared_ptr`
* `std::weak_ptr`

Ã–rnek:

```cpp
auto p = std::make_unique<int>(10);
// delete gerekmez
```

ğŸ“Œ Yeni baÅŸlayanlar iÃ§in new/delete Ã¶ÄŸrenmek Ã¶nemlidir ama **modern C++ uygulamalarÄ±nda** neredeyse hiÃ§ kullanÄ±lmaz.

---

## **8ï¸âƒ£ Shallow Copy vs Deep Copy (Ã–zellikle SÄ±nÄ±flarda)**

EÄŸer bir sÄ±nÄ±f heapâ€™te bellek aÃ§Ä±yorsa:

* Copy constructor
* Copy assignment operator
* Destructor

yazman gerekir. (Rule of 3/5/0)

Ã–rnek olarak:

```cpp
class Test {
    int* data;
public:
    Test() { data = new int(5); }
    ~Test() { delete data; }
};
```

Bu sÄ±nÄ±f **kopyalanÄ±rsa bÃ¼yÃ¼k hata oluÅŸur**, Ã§Ã¼nkÃ¼ aynÄ± pointer iki kez delete edilir.

---

## **9ï¸âƒ£ new ile oluÅŸturulan deÄŸiÅŸkenin Ã¶mrÃ¼ paranteze baÄŸlÄ± deÄŸildir**

Stack'teki gibi sÃ¼slÃ¼ parantezden Ã§Ä±kÄ±nca silinmez.

```cpp
{
    int* p = new int(7);
} // p scope dÄ±ÅŸÄ±na Ã§Ä±ktÄ± ama *p heap'te duruyor
```

Bu memory leakâ€™tir.
